WebDriver/BiDi 2020-04-20 会議議事録
https://docs.google.com/document/d/1qZcT2RBdmxbzVorV1hTUaH_sIvrhGYjZbP4rK0IpBEc/edit?tab=t.0#bookmark=id.tu7bmxwhyaem

# gpt の翻訳

WebDriver/BiDi 2020-04-20 会議議事録

## 出席者

Brandon Walderman、Microsoft、エンジニア、DevTools、Puppeteer/WebDriver/Playwright 間のギャップを埋め、すべてのブラウザに共通のバックエンドを指定することに関心がある
Brian Burg、Apple、SafariDriver & Web Inspector の TL、望む
Christian Bromann、Sauce Labs、webdriver.io のメンテナー/WebDriver クラウドベンダーの視点を提供することに関心がある
Devin Reams、Mozilla、Firefox DevTools の EM
Harald Kirschner、Mozilla、Firefox DevTools の PM
James Graham、Mozilla、現代の開発者の期待に合ったクロスブラウザテストの標準的な方法を望む
John Chen、Google、ChromeDriver の TL、ChromeDriver が BiDi を実装できるようにしたい
Maja Frydrychowicz、Mozilla、Henrik Skupin と共に Firefox のリモートプロトコル実装に取り組み、Puppeteer に貢献
Philip Jägenstedt、Google、エコシステムインフラチームを率いていた（現在は Stephen McGruer が担当）、現代のクロスブラウザテストの状況を解決したい
Robert Ma、Google、Web Platform Tests に取り組む
Shane Clifford、Microsoft、Edge DevTools
Shengfa Lin、Google、WebDriver に取り組む
Yang Guo、Google、Chrome DevTools のマネージャー
Zoher Ghadyali、Microsoft、Microsoft Edge チームの自動化ツールの PM、クロスブラウザストーリーを解決したい
Mathias Bynens、Google、Puppeteer とテストのための Chrome DevTools チームの TL
Guangyue Xu、Microsoft、DevTools、WebDriver、自動化に取り組む

## アジェンダ/ノート

自己紹介（前回以降の新しい参加者）+ BiDi に関する背景と目標
https://github.com/w3c/webdriver/blob/master/webdriver-bidi/webdriver.md のレビュー（前回からの John Chen の AI）
John Chen: 提案は合理的に見える
誰かからの実装/プロトタイプの意図は？ 最小限の有用な範囲？
James: 提案は方向性を示しているが、まだ仕様ではない。いくつかの具体的な問題を提起して、後で仕様になるように決定を始めることができる：
[BiDi] イベントストリームを有効にする方法を指定する
[BiDi] 値のシリアル化フォーマットを決定する
[BiDi] 説明文書の目標を更新する
[BiDi] 低レベルのトランスポートフォーマットを指定する
Brandon: 最後の 2 つは GitHub で多くの議論を生んでいる。リポジトリの目標が更新されるかもしれない。
Mathias: 何がブロックしているのか？

### 目標

James: 目標は合意する必要があるが、仕様の正式な部分ではない。仕様を書くための組織に関して、それはどのように見えるか？ すべての詳細に合意する必要はなく、高レベルをスケッチし始めることができる。1 つのモノリシックな文書ではなく、いくつかの別々の文書を持つかもしれない。
Philip: MVP は何か？ 最初にできるコアなことはあるか？
Brandon: 説明書の目標セクションは「BiDi はこれらすべてのことをできる必要がある」と言うつもりではなく、TPAC 後のブレインダンプをキャプチャするためのものだった。重要な項目の 1 つは、従来の WebDriver コマンドとの相互運用性だ。既存のテストスイートに機能を徐々に追加して、何も壊さずに済むと良い。CDP/ブラウザ固有のインスペクタープロトコルへのエスケープハッチとノード/バックエンドノード ID を取得する：必要な場合に備えて。しかし、これを指定する必要はなく、ベンダー拡張として行うことができる。
James: 人々がこれを頻繁に行いたくないというのは目標であるべきだ。たとえば CDP に戻りたい場合、それは私たちが埋めるべき機能のギャップを示唆している。
Yang: 私はこれをアップグレードパスとして見ている。BiDi が一晩で実装されることを期待することはできず、人々が徐々に BiDi の機能を使用するように切り替えることができるアップグレードパスを持つことは魅力的だ。たとえば Puppeteer から。
James: Chrome にとっては理にかなっているが、他のブラウザにとっては必ずしもそうではない。それは目標である必要はない。
Yang: 同意する。しかし、それは良いステッピングストーンだ。Puppeteer が徐々に BiDi に切り替えることを可能にするだろう。
James: Puppeteer のエンジニアリング選択としては理にかなっている。CDP に依存している既存のものがあり、人々は BiDi が同様に動作することを望むかもしれないので、既存の DevTools プロトコルを考慮することは理にかなっているが、それは目標であるべきではない。
Brandon: 仕様にこれを組み込むのではなく、各実装が getElement レスポンスにプロパティを追加したり、ベンダー固有の拡張を提供して翻訳することができる。
Mathias: SGTM。
Philip: メカニズムが不必要に異ならないように話し合うことはできる。
Brandon: BiDi で CDP ID を再利用することは避けるべきだ。そうでなければ、開発者は ID が一致することを期待するかもしれない。
James: シリアル化に関する問題はそれを解決するための適切な場所かもしれない。
Philip: ID を共有するべきだと主張しているのか？
James: いいえ、その問題を見てください。

### トランスポートプロトコル

Mathias: トランスポートプロトコルについて話しましょう: https://github.com/w3c/webdriver/issues/1498
Brandon: TPAC の決議は JSON-RPC を使用することだったが、意図は主に既存の仕様を使用し、実装とテストがあり信頼性があるものを使用することだった。しかし、JSON-RPC にはいくつかの問題がある：
技術的にはすべてのメッセージにバージョン番号が必要だが、それを省略することができるかもしれない
複数のコマンドをバッチ処理して一括でレスポンスを得ることは JSON-RPC では本当に可能ではない。JSON-RPC に触発された独自の低レベルプロトコルを定義して、独自の機能を追加するのはどうだろうか？ JSON-RPC の仕様よりもそれほど大きくはならないだろう。
Brian: 私たちには WebKit 固有の JSON-RPC とテストがある。すべての異なるコンテキスト、たとえばサービスワーカーを識別する方法は複雑になるだろう。既存のものをコピーして必要なものを追加する。バッチ処理に関する意味論的なこともある：キューにエラーがある場合、または要素が古くなった場合にどうするか？
Mathias: サービスワーカーで WebDriver を実行するとはどういう意味か？
Brian: 一部の実装では、特定のコンテキストにメッセージを送信し、それがトップレベルの UI プロセスに文字列として送信され、それがアンラップされる。内部文字列を常に送信したくない。どのプロセスが何をするかの完全な階層を公開する必要はない。
James: どのプロセスがどのメッセージをアンラップするかを指定する必要はない。特定の領域でこのスクリプトを実行する方法を指定する必要がある。メッセージがワイヤー上でどのように見えるかを指定し、残りは実装に任せるべきだ。パイプラインに関しては、JSON-RPC にはコマンドのリストを送信できる組み込みのメカニズムがあるが、特定の意味を実装する必要があり、私たちのユースケースには適していないようだ。私たちのユースケースには適していないようだ。JSON-RPC をそのまま使用しない理由のように思える。
Brian: 同意する。WebKit にはこれらのことを行う独自の方法がある。
James: 合意があるようだ：JSON-RPC を基にするが、拡張できる。
Philip: JSON ベースであることは問題か？
Brandon: 最終的には、サーバーバックエンドをモックし、リクエストをインターセプトするなどを行いたい。バイナリデータは base64 エンコーディングで処理できる。あるいは、Chromium のように CBOR を使用することもできる。
Mathias: より単純な例も：BigInt/Infinity は JSON では表現できない。もちろんカスタムシリアル化/デシリアル化を行うことはできる。
Brian: WebKit にとっては問題ではない。スクリーンショットを撮ると、それは 5 MB のテキストであり、大したことではない。JSON-RPC にはデータブロブのようなものはなく、たとえばチャンクメッセージを行うことができるが、これまでのところ WebKit ではその必要性を感じていない。
James: 通常、DevTools プロトコルはローカルデバイスをデバッグするための低遅延接続にある。BrowserStack/SauceLabs のリモートデバッグでは、要件が異なる。遅延に関してはもう少し重要だ。
Brandon: 遅延は確実に問題になるだろう。WebDriver-BiDi が実現すると、より多くの往復トラフィックが発生するため、メッセージを送信し続けるのではなく、テストスイート全体を送信する方が理にかなっているかもしれない。
Christian: SauceLabs でそれに取り組んでいる。この議論のブロッカーにはならないはずだ。
Brandon: それは遅延と接続性にも役立つだろう。
James: JSON を採用すべきか？ それが良い第一歩であるという弱いコンセンサスがあるようだ。後で人々が 60fps のスクリーンショットを撮っていることが判明した場合、v2 の機能としてよりコンパクトな表現を見つけることができるかもしれない。
Philip: 理にかなっている。既存の WebDriver エンドポイントとの互換性のために、JSON はどこかに含まれている必要がある。バイナリ表現が必要な場合、それは JSON モデルのスーパーセットである必要がある。

### イベントストリームを有効にする方法

James: イベントストリームを有効にする方法。これにはメカニズムが必要だ：たとえば、このウィンドウからすべてのイベントを取得したい、またはこのドキュメントからすべての DOM イベントを取得したい。CDP のドメインに似ており、有効/無効にできる。参照カウントが必要か？ クライアントの異なる部分が`enable`を呼び出し、1 つが`disable`を呼び出した場合、それでもイベントを取得するか？
Brandon: イベントを個別に登録できると良いので、互いに独立してイベントをリッスンし始めることができる。参照カウントには価値があると思う。CDP では、特定のコンテキストやフレームのネットワークイベントだけを取得したいという細かい方法はない。
Brian: コンテキストからのイベントを具体的にすることは脆弱になるだろう。テストをデバッグするのは災難になるだろう。フットガンを避けて、グローバルな有効/無効を持つだけにしよう。イベントは本当にセッションのプロパティだ。それをより具体的なものに依存させようとするのは過度に複雑に思える。たとえば「コンテキストが破棄された」-- どこにそれを登録するか？
James: 特定のフレームのネットワークログをオンにする。
Brian: ネットワークイベントの場合、フレームをロードする前にそれを有効にする必要がある。
James: すべてのトップレベルのブラウジングコンテキストに対してそれを有効にするよりも良いことができるはずだ。あるいは、ほとんどのテストシナリオで開いているすべてのものを知っているかもしれない？
Philip: このドメイン X のイベント A & B を取得するメカニズムを追加するのは難しいだろうか？
James: 理にかなっている。イベントをグローバルにオンにすることを可能にし、特定のブラウジングコンテキストやドメインの分離のための適切な単位にフィルタリングすることもできる。
Brandon: 2 つのことが有用に思える：1) ドメインごとにイベントをスライスする（たとえば、ネットワーキング、DOM、ログ）と、2) トップレベルのブラウジングコンテキストごとにスライスする。パフォーマンスのバランスが取れている（すべてのことを有効にしているわけではない）が、間違いを犯す可能性はまだ小さい。
James: Brian が言及したように、「ブラウジングコンテキスト」以外の何かになると思う。たとえば、サービスワーカーでログを有効にしたいかもしれない。
Brandon: たぶん「ターゲット」？ それはページやサービスワーカー、ウェブワーカーだ。
Brandon: サービスワーカーの作成自体がイベントであるため、どこかでそれを登録する必要がある。
Philip: このタイプのターゲットをリッスンする方法がある限り、それで良い。
James: それが現れたことを知った時点で、それはすでにそのことを行い、消えているかもしれない。

### まとめ

Zoher: James が最初に目標セクションを明確にすることを言及したのが好きだ。たくさんの書き込み/レビューを最初に行い、変更するのではなく、最初にそれを行うようにしよう。来月までにそれを完了するようにしよう。
Brandon: だから、AI は次の会議までに取り組むべき文書の初期リストを取得することだ。
James: それについての問題を開くのが理にかなっている。実装に関しては、興味はあるが、今のところ実装するものはあまりない。
Brandon: Chromium に関しては、私たちが話してきたことはすべて CDP で基本的に可能であり、Puppeteer で実装されていると思うので、その側でブロックするエンジニアリングの問題はないはずだ。主にユーザーに公開する API に関することになるだろう。
Zoher: 小さな機能に合意できれば、そのプロトタイプを作成し、それに応じて仕様を更新する。
James: 現在、実装するものは何もない。何らかの賛同を得て、ある程度仕様化されたものが欲しい。
Philip: 理にかなっている。これらのことは大きな未知数のようには聞こえないが、MVP を持つことができれば素晴らしいだろう。
